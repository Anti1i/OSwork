# OrangeS Shell扩展 - 技术实现路线

## 一、项目概述

### 1.1 项目目标
扩展OrangeS操作系统的Shell功能，实现进程管理、文件管理和多任务并发执行能力。

### 1.2 技术架构
```
┌─────────────────────────────────────────────────┐
│           用户交互层 (Shell)                      │
│  - 命令解析  - 参数处理  - 执行调度               │
└──────────────────┬──────────────────────────────┘
                   │
┌──────────────────▼──────────────────────────────┐
│          系统调用接口层 (lib/*.c)                 │
│  - 进程管理API  - 文件管理API  - IPC接口          │
└──────────────────┬──────────────────────────────┘
                   │
┌──────────────────▼──────────────────────────────┐
│          内核任务层 (MESSAGE机制)                 │
│  TASK_MM  │  TASK_FS  │  TASK_SYS  │  TASK_TTY  │
└──────────────────┬──────────────────────────────┘
                   │
┌──────────────────▼──────────────────────────────┐
│          硬件抽象层                              │
│  进程调度  │  文件系统  │  设备驱动               │
└─────────────────────────────────────────────────┘
```

---

## 二、功能模块实现路线

### 2.1 进程管理模块

#### 2.1.1 列出当前运行的进程 (`ps` 命令)

**技术方案:**
- 使用现有的 `PROPRINT` 消息类型（已在 `include/sys/const.h:220` 定义）
- 向 `TASK_FS` 发送 `PROPRINT` 消息获取进程表信息
- 解析并格式化显示进程信息

**实现步骤:**
1. 在 `command/` 目录创建 `ps.c` 命令程序
2. 利用系统调用向文件系统任务发送 `PROPRINT` 消息
3. 接收并解析进程表数据（来自 `proc_table[]`）
4. 格式化输出：PID、进程名、状态、优先级、父进程PID

**数据结构依赖:**
- `struct proc` (include/sys/proc.h:48-88)
- 进程表：`proc_table[NR_TASKS + NR_PROCS]`
- 进程标志：`p_flags` (0=可运行, 其他=阻塞/等待)

**输出格式设计:**
```
PID  NAME         STATUS    PRIORITY  PARENT  TICKS
---  -----------  --------  --------  ------  -----
0    TASK_TTY     RUNNING   15        -       10
1    TASK_SYS     BLOCKED   15        -       0
2    TASK_HD      RUNNING   15        -       5
...
6    INIT         RUNNING   1         -       1
7    TestA        RUNNING   1         6       2
```

#### 2.1.2 终止指定的进程 (`kill` 命令)

**技术方案:**
- 使用现有的 `PRO_KILL` 消息类型（已在 `include/sys/const.h:221` 定义）
- 向 `TASK_FS` 发送 `PRO_KILL` 消息请求终止进程
- 在 `fs/main.c` 的 `task_fs()` 中实现进程终止逻辑

**实现步骤:**
1. 创建 `command/kill.c` 命令程序
   - 接收参数：进程PID
   - 发送 `PRO_KILL` 消息到文件系统任务
2. 在 `fs/main.c` 的 `task_fs()` 添加 `PRO_KILL` 处理分支
   - 验证PID合法性（范围检查、系统任务保护）
   - 调用内核级进程终止函数
   - 清理进程资源（文件描述符、内存等）
3. 安全机制：
   - 禁止终止内核任务（PID < NR_TASKS）
   - 禁止终止INIT进程（PID = INIT）
   - 权限检查（可选，基于进程关系）

**消息结构:**
```c
MESSAGE msg;
msg.type = PRO_KILL;
msg.u.m1.m1i1 = target_pid;  // 目标进程PID
send_recv(BOTH, TASK_FS, &msg);
return msg.RETVAL;  // 0=成功, -1=失败
```

**错误处理:**
- PID不存在 → 返回错误码
- PID为系统任务 → 拒绝并返回错误
- 进程已终止 → 返回成功（幂等性）

---

### 2.2 文件管理模块

#### 2.2.1 列出当前目录的文件 (`ls` 命令增强)

**现状分析:**
- 已有 `command/ls.c` 实现基础功能
- 需要增强显示文件属性信息

**技术方案:**
- 使用 `SEARCH` 消息遍历目录（已实现）
- 使用 `STAT` 消息获取文件详细信息
- 格式化输出：类型、大小、扇区、inode号

**实现步骤:**
1. 增强 `command/ls.c`：
   - 对每个文件调用 `stat()` 获取详细信息
   - 解析 `i_mode` 字段识别文件类型
   - 格式化输出文件大小（字节）、扇区数等
2. 输出格式设计（参考Unix `ls -l`）：
```
TYPE  SIZE     SECTORS  INODE  NAME
----  -------  -------  -----  --------
DIR   0        0        0      /
REG   1024     2        10     readme.txt
CHR   0        0        2      dev_tty0
BLK   0        0        3      dev_hd0
REG   4096     8        11     kernel.bin
```

**文件类型识别:**
```c
#define I_REGULAR       0100000  // 普通文件 (REG)
#define I_DIRECTORY     0040000  // 目录 (DIR)
#define I_BLOCK_SPECIAL 0060000  // 块设备 (BLK)
#define I_CHAR_SPECIAL  0020000  // 字符设备 (CHR)
```

**stat结构使用:**
```c
struct stat {
    int st_dev;       // 设备号
    int st_ino;       // inode号
    int st_mode;      // 文件类型和权限
    int st_rdev;      // 设备inode号
    int st_size;      // 文件大小（字节）
};
```

#### 2.2.2 创建新文件 (`touch` 命令)

**现状分析:**
- 已有 `command/touch.c` 实现（见探索报告）

**验证和优化:**
1. 确认 `touch.c` 使用 `O_CREAT | O_RDWR` 标志
2. 添加错误处理：
   - 文件已存在 → 更新访问时间（可选）
   - 磁盘空间不足 → 返回错误
   - 路径不合法 → 提示用户
3. 支持批量创建：`touch file1 file2 file3`

#### 2.2.3 打开或编辑文件 (`open/edit` 命令)

**技术方案:**
- 检查文件类型（通过 `stat()` 获取 `i_mode`）
- **可执行文件** → 使用 `fork() + execv()` 执行
- **文本文件** → 调用文本编辑器（增强 `cat` 命令）

**实现步骤:**
1. 创建 `command/open.c`：
   ```c
   int main(int argc, char* argv[]) {
       // 1. 参数检查
       if (argc < 2) {
           printf("Usage: open <filename>\n");
           return 1;
       }

       // 2. 获取文件状态
       struct stat st;
       if (stat(argv[1], &st) != 0) {
           printf("File not found: %s\n", argv[1]);
           return 1;
       }

       // 3. 判断文件类型
       if (st.st_mode & I_REGULAR) {
           // 3a. 判断是否可执行（简化：检查文件名或魔数）
           if (is_executable(argv[1])) {
               // 执行程序
               execv(argv[1], &argv[1]);
           } else {
               // 打开文本编辑器
               char* editor_argv[] = {"cat", argv[1], NULL};
               execv("/cat", editor_argv);
           }
       } else {
           printf("Not a regular file\n");
           return 1;
       }
   }
   ```

2. 可执行文件识别方法：
   - **方法A（推荐）**: 检查文件内容前几字节（ELF魔数：0x7F 'E' 'L' 'F'）
   - **方法B（简化）**: 检查文件扩展名或位于 `/` 根目录

3. 增强 `command/cat.c` 作为文本编辑器：
   - 已支持读取和编辑功能
   - 添加保存功能（写回文件）
   - 添加交互式编辑模式

#### 2.2.4 删除指定文件 (`rm` 命令)

**现状分析:**
- 已有 `command/rm.c` 实现
- 使用 `unlink()` 系统调用删除文件

**验证和增强:**
1. 确认 `rm.c` 调用 `unlink()` 正确
2. 添加安全确认机制：
   ```c
   printf("Delete file '%s'? (y/n): ", filename);
   char confirm;
   read(0, &confirm, 1);
   if (confirm != 'y' && confirm != 'Y') {
       return 0;
   }
   ```
3. 支持批量删除：`rm file1 file2 file3`
4. 添加错误处理：
   - 文件不存在 → 提示
   - 无权限删除 → 提示（可选）

---

### 2.3 多任务并发执行模块

#### 2.3.1 现有机制分析

**当前Shell实现** (kernel/main.c:338-428):
- 已支持 `&` 符号分隔命令
- 使用 `fork()` 创建子进程并发执行
- 父进程通过 `wait()` 回收所有子进程

**示例:**
```bash
$ command1 & command2 & command3
```
执行流程：
1. 解析出3个命令
2. Fork子进程执行 `command1`（父进程继续）
3. Fork子进程执行 `command2`（父进程继续）
4. 执行 `command3`（父进程自己执行）
5. 调用 `wait()` 回收所有子进程

#### 2.3.2 优化和增强

**问题分析:**
- 当前实现正确，但缺少任务管理反馈
- 用户无法查看后台任务状态

**增强方案:**
1. **任务状态显示**：
   - 在 `fork()` 后打印：`[1] 进程ID: 123`
   - 在 `wait()` 后打印：`[1] Done: command1`

2. **后台任务符号**（可选高级功能）：
   - 支持 `command &` 语法（命令末尾 `&`）
   - 父进程不等待，立即返回Shell提示符
   - 实现简易作业控制

**实现步骤（基础版）:**
```c
// 在 shabby_shell() 中增强
int child_count = 0;
for (each command separated by &) {
    int pid = fork();
    if (pid == 0) {
        // 子进程执行命令
        execv(path, argv);
    } else {
        // 父进程记录子进程
        child_count++;
        printf("[%d] Started: PID=%d, CMD=%s\n", child_count, pid, cmd);
    }
}

// 等待所有子进程
for (int i = 0; i < child_count; i++) {
    int status;
    int pid = wait(&status);
    printf("[%d] Finished: PID=%d\n", i+1, pid);
}
```

#### 2.3.3 TTY并发安全

**现状:**
- OrangeS已有3个TTY设备：`/dev_tty0`, `/dev_tty1`, `/dev_tty2`
- 每个TTY有独立的输入/输出缓冲区
- INIT进程已在TTY1和TTY2启动独立Shell（见main.c:437-473）

**技术保障:**
- TTY驱动使用消息队列机制，天然支持并发
- 每个Shell进程独占一个TTY，无竞争
- 同一TTY上的多个子进程共享输出（通过内核缓冲同步）

**测试方案:**
```bash
# 在TTY1上
$ testA & testB & testC

# 在TTY2上（按Alt+F2切换）
$ ls & ps & pwd
```

---

## 三、系统调用支持分析

### 3.1 已有系统调用

| 调用 | 消息类型 | 功能 | 库文件 | 状态 |
|------|---------|------|--------|------|
| `open()` | OPEN | 打开/创建文件 | lib/open.c | ✅已实现 |
| `close()` | CLOSE | 关闭文件 | lib/close.c | ✅已实现 |
| `read()` | READ | 读文件 | lib/read.c | ✅已实现 |
| `write()` | WRITE | 写文件 | lib/write.c | ✅已实现 |
| `unlink()` | UNLINK | 删除文件 | lib/unlink.c | ✅已实现 |
| `stat()` | STAT | 获取文件信息 | lib/stat.c | ✅已实现 |
| `fork()` | FORK | 创建子进程 | lib/fork.c | ✅已实现 |
| `execv()` | EXEC | 执行程序 | lib/exec.c | ✅已实现 |
| `wait()` | WAIT | 等待子进程 | lib/wait.c | ✅已实现 |
| `exit()` | EXIT | 进程退出 | lib/exit.c | ✅已实现 |
| `getpid()` | GET_PID | 获取进程ID | lib/getpid.c | ✅已实现 |
| (自定义) | PROPRINT | 打印进程信息 | - | ⚠️需在FS中实现 |
| (自定义) | PRO_KILL | 杀死进程 | - | ⚠️需在FS中实现 |

### 3.2 需新增的系统调用接口

#### 3.2.1 进程列表查询

**库函数接口:**
```c
// lib/proprint.c
PUBLIC int proprint(char* buf, int buf_len) {
    MESSAGE msg;
    msg.type = PROPRINT;
    msg.BUF = buf;
    msg.BUF_LEN = buf_len;
    send_recv(BOTH, TASK_FS, &msg);
    return msg.RETVAL;
}
```

**FS任务处理:**
```c
// fs/main.c 中的 task_fs()
case PROPRINT:
    msg.RETVAL = do_proprint();
    break;

// fs/proprint.c (新建)
PUBLIC int do_proprint() {
    MESSAGE msg = fs_msg;
    char* buf = msg.BUF;
    int max_len = msg.BUF_LEN;

    // 遍历进程表
    int offset = 0;
    for (int i = 0; i < NR_TASKS + NR_PROCS; i++) {
        struct proc* p = &proc_table[i];
        if (p->p_flags == 0) {  // 可运行或运行中
            offset += sprintf(buf + offset,
                "%d\t%s\t%d\t%d\n",
                i,                  // PID
                p->name,            // 进程名
                p->priority,        // 优先级
                p->p_parent);       // 父进程PID
        }
        if (offset >= max_len - 100) break;
    }
    return offset;  // 返回写入的字节数
}
```

#### 3.2.2 进程终止

**库函数接口:**
```c
// lib/prokill.c
PUBLIC int prokill(int pid) {
    MESSAGE msg;
    msg.type = PRO_KILL;
    msg.u.m1.m1i1 = pid;
    send_recv(BOTH, TASK_FS, &msg);
    return msg.RETVAL;
}
```

**FS任务处理:**
```c
// fs/main.c
case PRO_KILL:
    msg.RETVAL = do_prokill();
    break;

// fs/prokill.c (新建)
PUBLIC int do_prokill() {
    int pid = fs_msg.u.m1.m1i1;

    // 安全检查
    if (pid < NR_TASKS) {
        printl("Cannot kill system task\n");
        return -1;
    }
    if (pid == INIT) {
        printl("Cannot kill INIT process\n");
        return -1;
    }
    if (pid >= NR_TASKS + NR_PROCS) {
        return -1;  // 非法PID
    }

    struct proc* p = &proc_table[pid];
    if (p->p_flags != 0) {
        return -1;  // 进程不存在或已终止
    }

    // 清理资源
    // 1. 关闭所有打开的文件
    for (int i = 0; i < NR_FILES; i++) {
        if (p->filp[i]) {
            // 调用 do_close() 关闭文件
        }
    }

    // 2. 通知MM任务释放内存
    MESSAGE msg;
    msg.type = EXIT;
    msg.u.m1.m1i1 = pid;
    send_recv(SEND, TASK_MM, &msg);

    // 3. 标记进程为终止状态
    p->p_flags = ZOMBIE;  // 或其他终止标志
    p->exit_status = SIGKILL;

    // 4. 通知父进程（如果父进程在wait）
    // ...

    return 0;
}
```

---

## 四、实现优先级和依赖关系

### 4.1 第一阶段：基础命令实现

**优先级：高** | **预期工期：2-3天**

1. ✅ `touch` - 创建文件（已有，验证即可）
2. ✅ `rm` - 删除文件（已有，验证即可）
3. 🔧 `ls` - 增强显示文件属性
4. 🆕 `ps` - 列出进程（新建）

**技术依赖:**
- 需要实现 `PROPRINT` 消息处理（fs/proprint.c）
- 需要创建库函数 `lib/proprint.c`

### 4.2 第二阶段：进程管理

**优先级：高** | **预期工期：3-4天**

1. 🆕 `kill` - 终止进程（新建）
2. 🔧 实现 `PRO_KILL` 消息处理（fs/prokill.c）
3. 🔧 创建库函数 `lib/prokill.c`
4. 🔧 添加进程资源清理逻辑

**技术难点:**
- 进程资源清理（文件描述符、内存）
- 与MM任务的协调
- 父子进程关系维护

### 4.3 第三阶段：文件操作增强

**优先级：中** | **预期工期：3-4天**

1. 🆕 `open` - 智能打开文件（新建）
2. 🔧 增强 `cat` - 添加编辑保存功能
3. 🔧 实现可执行文件检测逻辑
4. 🔧 完善错误处理和用户交互

### 4.4 第四阶段：多任务优化

**优先级：低** | **预期工期：2天**

1. 🔧 优化Shell的任务管理反馈
2. 🔧 添加后台任务状态显示
3. 🧪 多TTY并发测试
4. 📝 编写用户手册

---

## 五、测试方案

### 5.1 功能测试

**进程管理测试:**
```bash
# 测试1：列出进程
$ ps
PID  NAME         STATUS    PRIORITY  PARENT
0    TASK_TTY     RUNNING   15        -
...

# 测试2：启动后台进程
$ testA &
[1] Started: PID=10, CMD=testA

# 测试3：查看新进程
$ ps | grep testA
10   testA        RUNNING   1         7

# 测试4：终止进程
$ kill 10
Process 10 killed

# 测试5：验证进程终止
$ ps | grep testA
(无输出)
```

**文件管理测试:**
```bash
# 测试1：创建文件
$ touch myfile.txt
$ ls
REG   0        0        15     myfile.txt

# 测试2：编辑文件
$ open myfile.txt
(进入cat编辑模式)

# 测试3：查看文件属性
$ ls -l myfile.txt
TYPE  SIZE     SECTORS  INODE  NAME
REG   256      1        15     myfile.txt

# 测试4：删除文件
$ rm myfile.txt
Delete file 'myfile.txt'? (y/n): y
File deleted

# 测试5：验证删除
$ ls | grep myfile
(无输出)
```

**并发测试:**
```bash
# 测试1：同一TTY多命令
$ testA & testB & testC
[1] Started: PID=10, CMD=testA
[2] Started: PID=11, CMD=testB
[3] Started: PID=12, CMD=testC
...
[1] Finished: PID=10
[2] Finished: PID=11
[3] Finished: PID=12

# 测试2：多TTY并发（按Alt+F1, F2, F3切换）
# TTY1: $ ls & ps
# TTY2: $ touch file1 & touch file2
# TTY3: $ testA
# 验证：无死锁，各TTY独立运行
```

### 5.2 压力测试

```bash
# 测试1：大量进程创建
$ testA & testA & testA & ... (20个并发)
$ ps  # 验证所有进程正常

# 测试2：快速创建删除文件
for i in 1..100; do
    touch file$i
    rm file$i
done

# 测试3：进程终止压力
启动20个testA进程，然后逐一kill
```

### 5.3 安全测试

```bash
# 测试1：不允许杀死系统任务
$ kill 0
Error: Cannot kill system task

# 测试2：不允许杀死INIT
$ kill 6
Error: Cannot kill INIT process

# 测试3：不允许删除设备文件（可选）
$ rm /dev_tty0
Error: Cannot remove device file
```

---

## 六、潜在风险和缓解方案

### 6.1 技术风险

| 风险 | 影响 | 概率 | 缓解方案 |
|-----|------|------|---------|
| 进程表访问冲突 | 系统崩溃 | 中 | 使用消息机制原子操作，避免直接访问 |
| 文件系统损坏 | 数据丢失 | 低 | 实现事务性删除，添加日志记录 |
| 内存泄漏 | 系统变慢 | 中 | 确保所有资源在进程终止时释放 |
| 死锁 | 系统挂起 | 低 | 统一消息发送顺序，避免循环等待 |

### 6.2 实现风险

| 风险 | 影响 | 概率 | 缓解方案 |
|-----|------|------|---------|
| API不兼容 | 功能失效 | 中 | 仔细阅读现有代码，遵循现有模式 |
| 消息格式错误 | 通信失败 | 高 | 参考现有消息定义，添加调试日志 |
| 缓冲区溢出 | 安全漏洞 | 中 | 严格边界检查，使用安全字符串函数 |

---

## 七、开发环境和工具

### 7.1 编译工具链
- **汇编器**: nasm
- **编译器**: gcc
- **链接器**: ld
- **调试器**: gdb（可选）

### 7.2 开发流程
```bash
# 1. 编写代码
vim command/ps.c

# 2. 添加到Makefile
# 在COMMANDS变量中添加 ps

# 3. 编译
make

# 4. 创建镜像
make image

# 5. 运行测试
bochs  # 或 qemu
```

### 7.3 调试技巧
- 使用 `printl()` 输出调试信息到日志
- 使用 `printf()` 输出到TTY
- 利用 `disklog()` 记录文件系统操作
- Bochs调试器断点调试

---

## 八、文档和交付物

### 8.1 代码交付清单
- [ ] command/ps.c - 进程列表命令
- [ ] command/kill.c - 进程终止命令
- [ ] command/open.c - 智能文件打开命令
- [ ] lib/proprint.c - 进程打印库函数
- [ ] lib/prokill.c - 进程终止库函数
- [ ] fs/proprint.c - 进程打印FS处理
- [ ] fs/prokill.c - 进程终止FS处理
- [ ] 修改 command/ls.c - 增强文件属性显示
- [ ] 修改 command/cat.c - 增强编辑功能
- [ ] 修改 kernel/main.c - 优化Shell任务管理
- [ ] 修改 Makefile - 添加新命令编译

### 8.2 文档交付清单
- [x] 技术实现路线（本文档）
- [ ] 代码清单和API文档
- [ ] 用户使用手册
- [ ] 测试报告
- [ ] 开发总结和问题记录

---

## 九、参考资料

### 9.1 关键文件索引
- 系统调用定义：`include/sys/const.h`
- 进程结构：`include/sys/proc.h`
- 文件系统：`include/sys/fs.h`
- 函数原型：`include/sys/proto.h`
- Shell实现：`kernel/main.c:338-428`
- 文件系统任务：`fs/main.c`

### 9.2 关键数据结构
- `struct proc` - 进程控制块
- `struct inode` - 文件inode
- `MESSAGE` - 进程间消息
- `struct stat` - 文件状态信息

### 9.3 消息类型常量
- `PROPRINT` - 打印进程信息
- `PRO_KILL` - 终止进程
- `FORK`, `EXEC`, `WAIT`, `EXIT` - 进程管理
- `OPEN`, `CLOSE`, `READ`, `WRITE`, `UNLINK`, `STAT` - 文件操作

---

**文档版本**: 1.0
**创建日期**: 2026-01-01
**最后更新**: 2026-01-01
**状态**: 待审核
