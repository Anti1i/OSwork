# OrangeS Shell扩展 - 代码清单

## 目录
1. [现有代码清单](#一现有代码清单)
2. [需新增代码清单](#二需新增代码清单)
3. [需修改代码清单](#三需修改代码清单)
4. [核心API接口](#四核心api接口)
5. [数据结构定义](#五数据结构定义)
6. [系统调用详解](#六系统调用详解)

---

## 一、现有代码清单

### 1.1 内核核心文件

#### kernel/main.c
**关键函数：**
- `kernel_main()` (第29-127行)
  - 功能：内核入口，初始化所有任务和进程
  - 调用：`restart()`

- `Init()` (第437-473行)
  - 功能：INIT进程，解压tar、创建Shell
  - 系统调用：`open()`, `read()`, `close()`, `fork()`, `execl()`

- `shabby_shell()` (第338-428行)
  - 功能：Shell主循环，命令解析和执行
  - 参数：`const char* tty_name` - TTY设备名
  - 系统调用：`open()`, `read()`, `write()`, `fork()`, `execv()`, `wait()`
  - 支持：`&` 分隔符并发执行

#### kernel/proc.c
**关键函数：**
- `schedule()` (第36-55行)
  - 功能：进程调度器，选择下一个运行的进程
  - 算法：时间片轮转，选择ticks最大的进程

- `sys_sendrec()` (第92+行)
  - 功能：消息发送和接收的系统级实现
  - 参数：`int function, int src_dest, MESSAGE* msg, struct proc* p`

- `sys_check_stack()` (第64-90行)
  - 功能：检查进程栈是否溢出

**全局变量：**
```c
extern struct proc proc_table[NR_TASKS + NR_PROCS];  // 进程表
extern char task_stack[STACK_SIZE_TOTAL];             // 内核任务栈
extern struct task task_table[];                      // 任务表
```

#### kernel/systask.c
**关键函数：**
- `task_sys()` (整个文件)
  - 功能：系统任务主循环
  - 处理消息：
    - `GET_TICKS` - 获取系统滴答数
    - `GET_PID` - 获取进程ID
    - `GET_RTC_TIME` - 获取实时时钟

### 1.2 文件系统文件

#### fs/main.c
**关键函数：**
- `task_fs()` (第43-100行)
  - 功能：文件系统任务主循环
  - 处理消息：
    ```c
    case OPEN:      do_open();      break;
    case CLOSE:     do_close();     break;
    case READ:
    case WRITE:     do_rdwt();      break;
    case UNLINK:    do_unlink();    break;
    case RESUME:    do_resume();    break;
    case FORK:      do_fork();      break;
    case EXIT:      do_exit();      break;
    case LSEEK:     do_lseek();     break;
    case STAT:      do_stat();      break;
    case SEARCH:    (搜索目录);     break;
    case PROPRINT:  do_proprint();  break;  // 需新增
    case PRO_KILL:  do_prokill();   break;  // 需新增
    ```

- `init_fs()` (初始化函数)
  - 功能：初始化文件系统，加载超级块和inode

**全局变量：**
```c
extern struct file_desc f_desc_table[NR_FILE_DESC];  // 文件描述符表
extern struct inode inode_table[NR_INODE];           // inode表
extern struct super_block super_block[NR_SUPER_BLOCK]; // 超级块表
extern u8 fsbuf[FSBUF_SIZE];                         // FS缓冲区
extern MESSAGE fs_msg;                               // 当前处理的消息
```

#### fs/open.c
**关键函数：**
- `do_open()` (第19+行)
  - 功能：打开或创建文件
  - 处理标志：`O_CREAT`, `O_RDWR`, `O_TRUNC`
  - 返回：文件描述符

#### fs/read_write.c
**关键函数：**
- `do_rdwt()` (整个文件)
  - 功能：读写文件数据
  - 调用：`rw_sector()` 进行磁盘IO

#### fs/link.c
**关键函数：**
- `do_unlink()` (整个文件)
  - 功能：删除文件
  - 步骤：
    1. 查找目录项
    2. 清除inode映射位
    3. 清除扇区映射位
    4. 更新超级块

#### fs/misc.c
**关键函数：**
- `do_stat()` (整个文件)
  - 功能：获取文件状态信息
  - 返回：填充 `struct stat` 结构

- `strip_path()` (路径解析)
  - 功能：解析文件路径，分离文件名

- `search_file()` (文件搜索)
  - 功能：在目录中搜索文件

### 1.3 内存管理文件

#### mm/main.c
**关键函数：**
- `task_mm()` (主循环)
  - 功能：内存管理任务
  - 处理消息：
    - `FORK` - 分配进程内存
    - `EXIT` - 释放进程内存
    - `EXEC` - 加载程序

- `do_fork()` (进程分叉)
  - 功能：复制父进程内存给子进程

- `do_exit()` (进程退出)
  - 功能：释放进程占用的内存

#### mm/exec.c
**关键函数：**
- `do_exec()` (程序执行)
  - 功能：加载ELF可执行文件到内存
  - 步骤：
    1. 读取ELF头
    2. 分配内存
    3. 加载程序段
    4. 设置入口点

### 1.4 TTY和控制台文件

#### kernel/tty.c
**关键函数：**
- `task_tty()` (第1-100行)
  - 功能：TTY驱动任务主循环
  - 处理消息：
    - `DEV_OPEN` - 打开TTY设备
    - `DEV_READ` - 从TTY读取
    - `DEV_WRITE` - 向TTY写入
    - `HARD_INT` - 时钟中断（处理输入缓冲）

- `in_process()` (输入处理)
  - 功能：处理键盘输入，填充输入缓冲区

- `tty_do_read()` (TTY读取)
  - 功能：从输入缓冲区读取数据到进程

- `tty_do_write()` (TTY写入)
  - 功能：将进程数据写入控制台显示

**全局变量：**
```c
extern TTY tty_table[NR_CONSOLES];  // TTY设备表（3个）
```

#### kernel/console.c
**关键函数：**
- `init_screen()` (初始化屏幕)
- `out_char()` (输出字符)
- `scroll_screen()` (屏幕滚动)
- `select_console()` (切换控制台)
- `set_cursor()` (设置光标位置)
- `set_video_start_addr()` (设置显存起始地址)

**全局变量：**
```c
extern CONSOLE console_table[NR_CONSOLES];  // 控制台表（3个）
extern int nr_current_console;              // 当前控制台号
```

#### kernel/keyboard.c
**关键函数：**
- `keyboard_handler()` (键盘中断处理)
- `init_keyboard()` (初始化键盘)
- `keyboard_read()` (读取键盘扫描码)
- `get_byte_from_kbuf()` (从键盘缓冲区获取字节)

### 1.5 库函数文件

#### lib/syscall.asm
**汇编宏：**
```asm
; 系统调用入口
; int 0x90
; eax: 消息指针
; ebx: src_dest
; ecx: function (SEND/RECEIVE/BOTH)
```

#### lib/open.c
```c
PUBLIC int open(const char* pathname, int flags) {
    MESSAGE msg;
    msg.type = OPEN;
    msg.PATHNAME = (void*)pathname;
    msg.FLAGS = flags;
    msg.NAME_LEN = strlen(pathname);
    send_recv(BOTH, TASK_FS, &msg);
    return msg.FD;
}
```

#### lib/close.c
```c
PUBLIC int close(int fd) {
    MESSAGE msg;
    msg.type = CLOSE;
    msg.FD = fd;
    send_recv(BOTH, TASK_FS, &msg);
    return msg.RETVAL;
}
```

#### lib/read.c
```c
PUBLIC int read(int fd, void* buf, int count) {
    MESSAGE msg;
    msg.type = READ;
    msg.FD = fd;
    msg.BUF = buf;
    msg.CNT = count;
    send_recv(BOTH, TASK_FS, &msg);
    return msg.CNT;
}
```

#### lib/write.c
```c
PUBLIC int write(int fd, const void* buf, int count) {
    MESSAGE msg;
    msg.type = WRITE;
    msg.FD = fd;
    msg.BUF = (void*)buf;
    msg.CNT = count;
    send_recv(BOTH, TASK_FS, &msg);
    return msg.CNT;
}
```

#### lib/fork.c
```c
PUBLIC int fork() {
    MESSAGE msg;
    msg.type = FORK;
    send_recv(BOTH, TASK_MM, &msg);
    return msg.RETVAL;  // 父进程返回子PID，子进程返回0
}
```

#### lib/exec.c
```c
PUBLIC int execv(const char* path, char* argv[]) {
    MESSAGE msg;
    msg.type = EXEC;
    msg.PATHNAME = (void*)path;
    msg.BUF = (void*)argv;
    msg.NAME_LEN = strlen(path);
    send_recv(BOTH, TASK_MM, &msg);
    // 如果返回，说明exec失败
    return msg.RETVAL;
}
```

#### lib/wait.c
```c
PUBLIC int wait(int* status) {
    MESSAGE msg;
    msg.type = WAIT;
    send_recv(BOTH, TASK_MM, &msg);
    *status = msg.u.m3.m3i2;  // 子进程退出状态
    return msg.RETVAL;         // 子进程PID
}
```

#### lib/exit.c
```c
PUBLIC void exit(int status) {
    MESSAGE msg;
    msg.type = EXIT;
    msg.u.m3.m3i1 = status;
    send_recv(BOTH, TASK_MM, &msg);
    // 永不返回
}
```

#### lib/stat.c
```c
PUBLIC int stat(const char* path, struct stat* buf) {
    MESSAGE msg;
    msg.type = STAT;
    msg.PATHNAME = (void*)path;
    msg.BUF = buf;
    msg.NAME_LEN = strlen(path);
    send_recv(BOTH, TASK_FS, &msg);
    return msg.RETVAL;
}
```

#### lib/unlink.c
```c
PUBLIC int unlink(const char* pathname) {
    MESSAGE msg;
    msg.type = UNLINK;
    msg.PATHNAME = (void*)pathname;
    msg.NAME_LEN = strlen(pathname);
    send_recv(BOTH, TASK_FS, &msg);
    return msg.RETVAL;
}
```

#### lib/getpid.c
```c
PUBLIC int getpid() {
    MESSAGE msg;
    msg.type = GET_PID;
    send_recv(BOTH, TASK_SYS, &msg);
    return msg.RETVAL;
}
```

### 1.6 现有命令程序

#### command/ls.c
**功能：**列出目录内容
**系统调用：**`open()`, `read()`, `close()`
**现有输出：**简单文件名列表

**关键代码片段：**
```c
int main(int argc, char* argv[]) {
    char path[128] = "/";
    if (argc > 1) strcpy(path, argv[1]);

    int fd = open(path, O_RDONLY);
    if (fd == -1) {
        printf("Cannot open %s\n", path);
        return 1;
    }

    struct dir_entry de;
    while (read(fd, &de, sizeof(de)) == sizeof(de)) {
        if (de.inode_nr != 0) {
            printf("%s\n", de.name);
        }
    }

    close(fd);
    return 0;
}
```

#### command/touch.c
**功能：**创建空文件
**系统调用：**`open()`, `close()`

**关键代码：**
```c
int main(int argc, char* argv[]) {
    if (argc < 2) {
        printf("Usage: touch <filename>\n");
        return 1;
    }

    int fd = open(argv[1], O_CREAT | O_RDWR);
    if (fd == -1) {
        printf("Failed to create %s\n", argv[1]);
        return 1;
    }

    close(fd);
    printf("File created: %s\n", argv[1]);
    return 0;
}
```

#### command/rm.c
**功能：**删除文件
**系统调用：**`unlink()`

**关键代码：**
```c
int main(int argc, char* argv[]) {
    if (argc < 2) {
        printf("Usage: rm <filename>\n");
        return 1;
    }

    if (unlink(argv[1]) == 0) {
        printf("File deleted: %s\n", argv[1]);
        return 0;
    } else {
        printf("Failed to delete %s\n", argv[1]);
        return 1;
    }
}
```

#### command/cat.c
**功能：**查看和编辑文件（支持加密）
**系统调用：**`open()`, `read()`, `write()`, `close()`

**关键功能：**
- 读取文件内容显示
- 简单的文本编辑
- 文件加密/解密（XOR）

#### command/echo.c
**功能：**打印文本
**系统调用：**`printf()`（实际是write到stdout）

#### command/pwd.c
**功能：**打印当前工作目录
**实现：**直接打印 "/"（OrangeS暂无目录切换）

---

## 二、需新增代码清单

### 2.1 进程管理命令

#### command/ps.c (新建)
**文件位置：**`/home/user/OSwork/command/ps.c`
**功能：**列出当前运行的进程
**依赖：**`lib/proprint.c`, `fs/proprint.c`

**完整代码：**
```c
/************************************************************************
* 文件名：ps.c
* 描述：  列出当前运行的进程
* 作者：  OrangeS Shell Extension
* 日期：  2026-01-01
************************************************************************/

#include "type.h"
#include "stdio.h"
#include "const.h"
#include "protect.h"
#include "string.h"
#include "fs.h"
#include "proc.h"
#include "tty.h"
#include "console.h"
#include "global.h"
#include "proto.h"

// 外部函数声明
extern int proprint(char* buf, int buf_len);

int main(int argc, char* argv[]) {
    // 分配缓冲区接收进程信息
    char buf[2048];
    memset(buf, 0, sizeof(buf));

    // 调用系统调用获取进程信息
    int len = proprint(buf, sizeof(buf));

    if (len < 0) {
        printf("Failed to get process list\n");
        return 1;
    }

    // 打印表头
    printf("PID\tNAME\t\tSTATUS\tPRI\tPARENT\tTICKS\n");
    printf("---\t----\t\t------\t---\t------\t-----\n");

    // 打印进程信息
    printf("%s", buf);

    return 0;
}
```

**编译命令：**
```makefile
ps: command/ps.c lib/orangescrt.a
	$(CC) $(CFLAGS) -o ps command/ps.c lib/orangescrt.a
```

#### command/kill.c (新建)
**文件位置：**`/home/user/OSwork/command/kill.c`
**功能：**终止指定进程
**依赖：**`lib/prokill.c`, `fs/prokill.c`

**完整代码：**
```c
/************************************************************************
* 文件名：kill.c
* 描述：  终止指定的进程
* 用法：  kill <PID>
* 作者：  OrangeS Shell Extension
* 日期：  2026-01-01
************************************************************************/

#include "type.h"
#include "stdio.h"
#include "const.h"
#include "protect.h"
#include "string.h"
#include "fs.h"
#include "proc.h"
#include "tty.h"
#include "console.h"
#include "global.h"
#include "proto.h"

// 外部函数声明
extern int prokill(int pid);

// 简单的字符串转整数函数
int str_to_int(const char* str) {
    int result = 0;
    int i = 0;

    // 处理负数（虽然PID不应该为负）
    int sign = 1;
    if (str[0] == '-') {
        sign = -1;
        i = 1;
    }

    while (str[i] >= '0' && str[i] <= '9') {
        result = result * 10 + (str[i] - '0');
        i++;
    }

    return result * sign;
}

int main(int argc, char* argv[]) {
    // 参数检查
    if (argc < 2) {
        printf("Usage: kill <PID>\n");
        printf("Example: kill 10\n");
        return 1;
    }

    // 转换PID
    int pid = str_to_int(argv[1]);

    if (pid < 0) {
        printf("Invalid PID: %s\n", argv[1]);
        return 1;
    }

    // 调用系统调用终止进程
    int ret = prokill(pid);

    if (ret == 0) {
        printf("Process %d killed successfully\n", pid);
        return 0;
    } else if (ret == -1) {
        printf("Failed to kill process %d\n", pid);
        printf("Possible reasons:\n");
        printf("  - Process does not exist\n");
        printf("  - Cannot kill system tasks (PID < 5)\n");
        printf("  - Cannot kill INIT process\n");
        return 1;
    } else {
        printf("Unknown error: %d\n", ret);
        return 1;
    }
}
```

#### command/open.c (新建)
**文件位置：**`/home/user/OSwork/command/open.c`
**功能：**智能打开文件（可执行文件运行，文本文件编辑）

**完整代码：**
```c
/************************************************************************
* 文件名：open.c
* 描述：  智能打开文件
*       - 可执行文件：运行
*       - 文本文件：使用cat编辑
* 用法：  open <filename>
* 作者：  OrangeS Shell Extension
* 日期：  2026-01-01
************************************************************************/

#include "type.h"
#include "stdio.h"
#include "const.h"
#include "protect.h"
#include "string.h"
#include "fs.h"
#include "proc.h"
#include "tty.h"
#include "console.h"
#include "global.h"
#include "proto.h"

// 检查是否为可执行文件
// 方法：检查ELF魔数 0x7F 'E' 'L' 'F'
int is_executable(const char* filename) {
    int fd = open(filename, O_RDONLY);
    if (fd == -1) {
        return 0;
    }

    unsigned char magic[4];
    int n = read(fd, magic, 4);
    close(fd);

    if (n != 4) {
        return 0;
    }

    // 检查ELF魔数
    if (magic[0] == 0x7F &&
        magic[1] == 'E' &&
        magic[2] == 'L' &&
        magic[3] == 'F') {
        return 1;
    }

    return 0;
}

int main(int argc, char* argv[]) {
    // 参数检查
    if (argc < 2) {
        printf("Usage: open <filename>\n");
        return 1;
    }

    const char* filename = argv[1];

    // 获取文件状态
    struct stat st;
    if (stat(filename, &st) != 0) {
        printf("File not found: %s\n", filename);
        return 1;
    }

    // 检查文件类型
    if (!(st.st_mode & I_REGULAR)) {
        printf("Not a regular file: %s\n", filename);
        return 1;
    }

    // 判断是否为可执行文件
    if (is_executable(filename)) {
        // 执行程序
        printf("Executing: %s\n", filename);

        // 构建新的argv（跳过"open"命令本身）
        char** new_argv = &argv[1];
        execv(filename, new_argv);

        // 如果execv返回，说明执行失败
        printf("Failed to execute: %s\n", filename);
        return 1;
    } else {
        // 使用cat打开文本文件
        printf("Opening text file: %s\n", filename);

        char* cat_argv[] = {"/cat", (char*)filename, NULL};
        execv("/cat", cat_argv);

        // 如果execv返回，说明执行失败
        printf("Failed to open editor\n");
        return 1;
    }

    return 0;
}
```

### 2.2 进程管理库函数

#### lib/proprint.c (新建)
**文件位置：**`/home/user/OSwork/lib/proprint.c`
**功能：**进程列表系统调用库函数

**完整代码：**
```c
/************************************************************************
* 文件名：proprint.c
* 描述：  进程列表打印系统调用
* 函数：  int proprint(char* buf, int buf_len)
* 返回：  写入缓冲区的字节数，失败返回-1
* 作者：  OrangeS Shell Extension
* 日期：  2026-01-01
************************************************************************/

#include "type.h"
#include "const.h"
#include "protect.h"
#include "proto.h"
#include "string.h"
#include "proc.h"
#include "global.h"

/*****************************************************************************
 * 函数名: proprint
 * 描述:   获取当前系统中所有进程的信息
 * 参数:   buf     - 接收进程信息的缓冲区
 *        buf_len - 缓冲区大小
 * 返回值: 成功返回写入的字节数，失败返回-1
 *****************************************************************************/
PUBLIC int proprint(char* buf, int buf_len) {
    MESSAGE msg;

    msg.type = PROPRINT;
    msg.BUF = buf;
    msg.BUF_LEN = buf_len;

    send_recv(BOTH, TASK_FS, &msg);

    return msg.RETVAL;
}
```

#### lib/prokill.c (新建)
**文件位置：**`/home/user/OSwork/lib/prokill.c`
**功能：**进程终止系统调用库函数

**完整代码：**
```c
/************************************************************************
* 文件名：prokill.c
* 描述：  进程终止系统调用
* 函数：  int prokill(int pid)
* 返回：  成功返回0，失败返回-1
* 作者：  OrangeS Shell Extension
* 日期：  2026-01-01
************************************************************************/

#include "type.h"
#include "const.h"
#include "protect.h"
#include "proto.h"
#include "string.h"
#include "proc.h"
#include "global.h"

/*****************************************************************************
 * 函数名: prokill
 * 描述:   终止指定的进程
 * 参数:   pid - 要终止的进程ID
 * 返回值: 成功返回0，失败返回-1
 *****************************************************************************/
PUBLIC int prokill(int pid) {
    MESSAGE msg;

    msg.type = PRO_KILL;
    msg.u.m1.m1i1 = pid;  // 目标进程PID

    send_recv(BOTH, TASK_FS, &msg);

    return msg.RETVAL;
}
```

### 2.3 文件系统任务处理函数

#### fs/proprint.c (新建)
**文件位置：**`/home/user/OSwork/fs/proprint.c`
**功能：**文件系统任务中的进程列表处理

**完整代码：**
```c
/************************************************************************
* 文件名：proprint.c
* 描述：  处理PROPRINT消息，返回进程列表
* 作者：  OrangeS Shell Extension
* 日期：  2026-01-01
************************************************************************/

#include "type.h"
#include "const.h"
#include "protect.h"
#include "string.h"
#include "proc.h"
#include "tty.h"
#include "console.h"
#include "global.h"
#include "proto.h"
#include "fs.h"

// 辅助函数：整数转字符串
PRIVATE int int_to_str(int num, char* str) {
    if (num == 0) {
        str[0] = '0';
        str[1] = '\0';
        return 1;
    }

    char temp[20];
    int i = 0;
    int is_negative = 0;

    if (num < 0) {
        is_negative = 1;
        num = -num;
    }

    while (num > 0) {
        temp[i++] = '0' + (num % 10);
        num /= 10;
    }

    int j = 0;
    if (is_negative) {
        str[j++] = '-';
    }

    while (i > 0) {
        str[j++] = temp[--i];
    }
    str[j] = '\0';

    return j;
}

// 辅助函数：字符串连接
PRIVATE int str_append(char* dest, const char* src, int max_len, int current_len) {
    int i = 0;
    while (src[i] != '\0' && current_len < max_len - 1) {
        dest[current_len++] = src[i++];
    }
    dest[current_len] = '\0';
    return current_len;
}

/*****************************************************************************
 * 函数名: do_proprint
 * 描述:   遍历进程表，格式化输出进程信息到缓冲区
 * 返回值: 写入的字节数
 *****************************************************************************/
PUBLIC int do_proprint() {
    char* buf = fs_msg.BUF;
    int max_len = fs_msg.BUF_LEN;
    int offset = 0;
    char temp[128];
    char num_str[20];

    // 遍历进程表
    for (int i = 0; i < NR_TASKS + NR_PROCS; i++) {
        struct proc* p = &proc_table[i];

        // 只显示存在的进程（p_flags != FREE）
        // FREE通常用某个特殊值表示，这里假设非FREE进程的name非空
        if (p->name[0] == '\0') {
            continue;  // 跳过空进程槽
        }

        // 格式化一行：PID\tNAME\tSTATUS\tPRI\tPARENT\tTICKS\n
        offset = str_append(buf, "", max_len, offset);  // 清空temp

        // PID
        int_to_str(i, num_str);
        offset = str_append(buf, num_str, max_len, offset);
        offset = str_append(buf, "\t", max_len, offset);

        // NAME
        offset = str_append(buf, p->name, max_len, offset);
        offset = str_append(buf, "\t", max_len, offset);
        if (strlen(p->name) < 8) {  // 对齐
            offset = str_append(buf, "\t", max_len, offset);
        }

        // STATUS
        if (p->p_flags == 0) {
            offset = str_append(buf, "RUN", max_len, offset);
        } else {
            offset = str_append(buf, "BLOCK", max_len, offset);
        }
        offset = str_append(buf, "\t", max_len, offset);

        // PRIORITY
        int_to_str(p->priority, num_str);
        offset = str_append(buf, num_str, max_len, offset);
        offset = str_append(buf, "\t", max_len, offset);

        // PARENT
        if (p->p_parent == NO_TASK) {
            offset = str_append(buf, "-", max_len, offset);
        } else {
            int_to_str(p->p_parent, num_str);
            offset = str_append(buf, num_str, max_len, offset);
        }
        offset = str_append(buf, "\t", max_len, offset);

        // TICKS
        int_to_str(p->ticks, num_str);
        offset = str_append(buf, num_str, max_len, offset);
        offset = str_append(buf, "\n", max_len, offset);

        // 防止缓冲区溢出
        if (offset >= max_len - 100) {
            break;
        }
    }

    return offset;
}
```

#### fs/prokill.c (新建)
**文件位置：**`/home/user/OSwork/fs/prokill.c`
**功能：**文件系统任务中的进程终止处理

**完整代码：**
```c
/************************************************************************
* 文件名：prokill.c
* 描述：  处理PRO_KILL消息，终止指定进程
* 作者：  OrangeS Shell Extension
* 日期：  2026-01-01
************************************************************************/

#include "type.h"
#include "const.h"
#include "protect.h"
#include "string.h"
#include "proc.h"
#include "tty.h"
#include "console.h"
#include "global.h"
#include "proto.h"
#include "fs.h"

/*****************************************************************************
 * 函数名: do_prokill
 * 描述:   终止指定的进程
 * 返回值: 成功返回0，失败返回-1
 *****************************************************************************/
PUBLIC int do_prokill() {
    int pid = fs_msg.u.m1.m1i1;

    // 安全检查1：PID范围检查
    if (pid < 0 || pid >= NR_TASKS + NR_PROCS) {
        printl("prokill: Invalid PID %d\n", pid);
        return -1;
    }

    // 安全检查2：禁止杀死系统任务
    if (pid < NR_TASKS) {
        printl("prokill: Cannot kill system task (PID %d)\n", pid);
        return -1;
    }

    // 安全检查3：禁止杀死INIT进程
    // INIT通常是第一个用户进程，PID为NR_TASKS
    if (pid == INIT) {
        printl("prokill: Cannot kill INIT process\n");
        return -1;
    }

    struct proc* p = &proc_table[pid];

    // 检查进程是否存在
    if (p->name[0] == '\0') {
        printl("prokill: Process %d does not exist\n", pid);
        return -1;
    }

    // 如果进程已经是僵尸状态，直接返回成功（幂等性）
    if (p->p_flags & ZOMBIE) {
        return 0;
    }

    printl("prokill: Killing process %d (%s)\n", pid, p->name);

    // 步骤1：关闭所有打开的文件
    for (int i = 0; i < NR_FILES; i++) {
        if (p->filp[i]) {
            // 减少文件描述符引用计数
            if (--p->filp[i]->fd_cnt == 0) {
                // 如果引用计数为0，减少inode引用计数
                p->filp[i]->fd_inode->i_cnt--;
            }
            p->filp[i] = NULL;
        }
    }

    // 步骤2：通知MM任务释放内存
    MESSAGE msg;
    msg.type = EXIT;
    msg.u.m3.m3i1 = pid;
    msg.u.m3.m3i2 = 0x9;  // SIGKILL信号
    send_recv(SEND, TASK_MM, &msg);
    // 注意：使用SEND而不是BOTH，因为不需要等待MM的响应

    // 步骤3：标记进程为僵尸状态
    p->p_flags = ZOMBIE;
    p->exit_status = 0x9;  // SIGKILL

    // 步骤4：如果父进程在等待，唤醒它
    // 这需要检查父进程的p_recvfrom字段
    if (p->p_parent != NO_TASK) {
        struct proc* parent = &proc_table[p->p_parent];
        if (parent->p_recvfrom == WAIT) {
            // 唤醒父进程（设置p_flags为0，可运行）
            // 这部分逻辑可能需要在MM任务中处理
        }
    }

    // 步骤5：将子进程过继给INIT
    for (int i = NR_TASKS; i < NR_TASKS + NR_PROCS; i++) {
        if (proc_table[i].p_parent == pid) {
            proc_table[i].p_parent = INIT;
        }
    }

    printl("prokill: Process %d killed successfully\n", pid);

    return 0;
}
```

---

## 三、需修改代码清单

### 3.1 文件系统主循环

#### fs/main.c
**需要修改的位置：**`task_fs()` 函数的switch语句

**修改前：**
```c
void task_fs() {
    // ... 初始化代码 ...

    while (1) {
        send_recv(RECEIVE, ANY, &fs_msg);

        int msgtype = fs_msg.type;
        int src = fs_msg.source;

        switch (msgtype) {
        case OPEN:
            fs_msg.RETVAL = do_open();
            break;
        case CLOSE:
            fs_msg.RETVAL = do_close();
            break;
        // ... 其他case ...
        default:
            dump_msg("FS::unknown message", &fs_msg);
            assert(0);
            break;
        }

        send_recv(SEND, src, &fs_msg);
    }
}
```

**修改后：**
```c
void task_fs() {
    // ... 初始化代码 ...

    while (1) {
        send_recv(RECEIVE, ANY, &fs_msg);

        int msgtype = fs_msg.type;
        int src = fs_msg.source;

        switch (msgtype) {
        case OPEN:
            fs_msg.RETVAL = do_open();
            break;
        case CLOSE:
            fs_msg.RETVAL = do_close();
            break;
        // ... 其他case ...

        // === 新增部分开始 ===
        case PROPRINT:
            fs_msg.RETVAL = do_proprint();
            break;
        case PRO_KILL:
            fs_msg.RETVAL = do_prokill();
            break;
        // === 新增部分结束 ===

        default:
            dump_msg("FS::unknown message", &fs_msg);
            assert(0);
            break;
        }

        send_recv(SEND, src, &fs_msg);
    }
}
```

### 3.2 增强ls命令

#### command/ls.c
**需要添加：**文件属性显示功能

**修改后的完整代码：**
```c
/************************************************************************
* 文件名：ls.c (增强版)
* 描述：  列出目录内容，显示文件详细属性
* 作者：  OrangeS Shell Extension
* 日期：  2026-01-01
************************************************************************/

#include "type.h"
#include "stdio.h"
#include "const.h"
#include "protect.h"
#include "string.h"
#include "fs.h"
#include "proc.h"
#include "tty.h"
#include "console.h"
#include "global.h"
#include "proto.h"

// 文件类型字符串
const char* get_file_type(int mode) {
    if (mode & I_DIRECTORY) return "DIR";
    if (mode & I_CHAR_SPECIAL) return "CHR";
    if (mode & I_BLOCK_SPECIAL) return "BLK";
    if (mode & I_REGULAR) return "REG";
    return "UNK";
}

int main(int argc, char* argv[]) {
    int show_detail = 0;  // 是否显示详细信息
    char path[128] = "/";

    // 解析参数
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-l") == 0) {
            show_detail = 1;
        } else {
            strcpy(path, argv[i]);
        }
    }

    // 打开目录
    int fd = open(path, O_RDONLY);
    if (fd == -1) {
        printf("Cannot open %s\n", path);
        return 1;
    }

    // 如果显示详细信息，打印表头
    if (show_detail) {
        printf("TYPE\tSIZE\tSECTORS\tINODE\tNAME\n");
        printf("----\t----\t-------\t-----\t----\n");
    }

    // 读取目录项
    struct dir_entry de;
    while (read(fd, &de, sizeof(de)) == sizeof(de)) {
        if (de.inode_nr == 0) {
            continue;  // 跳过空目录项
        }

        if (show_detail) {
            // 构造完整路径
            char full_path[256];
            if (strcmp(path, "/") == 0) {
                sprintf(full_path, "/%s", de.name);
            } else {
                sprintf(full_path, "%s/%s", path, de.name);
            }

            // 获取文件状态
            struct stat st;
            if (stat(full_path, &st) == 0) {
                printf("%s\t%d\t%d\t%d\t%s\n",
                    get_file_type(st.st_mode),
                    st.st_size,
                    (st.st_size + 511) / 512,  // 计算占用扇区数
                    de.inode_nr,
                    de.name);
            } else {
                printf("???\t?\t?\t%d\t%s\n", de.inode_nr, de.name);
            }
        } else {
            // 简单模式，只显示文件名
            printf("%s\n", de.name);
        }
    }

    close(fd);
    return 0;
}
```

### 3.3 Shell任务管理优化

#### kernel/main.c - shabby_shell()
**优化：**添加后台任务反馈

**修改位置：**`shabby_shell()` 函数中的fork和wait部分

**关键修改片段：**
```c
void shabby_shell(const char* tty_name) {
    // ... 前面的代码不变 ...

    while (1) {
        // ... 读取命令，解析argv ...

        int child_count = 0;
        int child_pids[10];  // 记录子进程PID
        char* child_cmds[10]; // 记录子进程命令

        // 遍历所有命令（按&分隔）
        while (current_cmd < total_cmds) {
            int pid = fork();

            if (pid != 0) {  // 父进程
                // 记录子进程信息
                if (child_count < 10) {
                    child_pids[child_count] = pid;
                    child_cmds[child_count] = argv[0];  // 命令名
                    child_count++;

                    // 打印启动信息
                    printf("[%d] Started: PID=%d, CMD=%s\n",
                           child_count, pid, argv[0]);
                }
            } else {  // 子进程
                execv(path, argv);
                printf("exec failed: %s\n", argv[0]);
                exit(1);
            }

            current_cmd++;
        }

        // 等待所有子进程
        for (int i = 0; i < child_count; i++) {
            int status;
            int pid = wait(&status);

            // 查找对应的命令
            for (int j = 0; j < child_count; j++) {
                if (child_pids[j] == pid) {
                    printf("[%d] Finished: PID=%d, CMD=%s, STATUS=%d\n",
                           j+1, pid, child_cmds[j], status);
                    break;
                }
            }
        }
    }
}
```

### 3.4 Makefile修改

**需要添加的内容：**

```makefile
# === 新增命令编译规则 ===

# 进程管理命令
PS = ps
KILL = kill
OPENFILE = open

# 更新COMMANDS列表
COMMANDS = ... touch rm ls cat echo pwd $(PS) $(KILL) $(OPENFILE)

# 编译规则
$(PS): command/ps.c $(LIB)
	$(CC) $(CFLAGS) -o $@ $< $(LIB)

$(KILL): command/kill.c $(LIB)
	$(CC) $(CFLAGS) -o $@ $< $(LIB)

$(OPENFILE): command/open.c $(LIB)
	$(CC) $(CFLAGS) -o $@ $< $(LIB)

# === 新增库函数 ===

# 更新LOBJS
LOBJS = ... lib/proprint.o lib/prokill.o

# 编译规则
lib/proprint.o: lib/proprint.c
	$(CC) $(CFLAGS) -c -o $@ $<

lib/prokill.o: lib/prokill.c
	$(CC) $(CFLAGS) -c -o $@ $<

# === 新增FS模块 ===

# 更新FSOBJS
FSOBJS = ... fs/proprint.o fs/prokill.o

# 编译规则
fs/proprint.o: fs/proprint.c
	$(CC) $(CFLAGS) -c -o $@ $<

fs/prokill.o: fs/prokill.c
	$(CC) $(CFLAGS) -c -o $@ $<
```

---

## 四、核心API接口

### 4.1 进程管理API

| 函数原型 | 功能 | 参数 | 返回值 |
|---------|------|------|--------|
| `int fork()` | 创建子进程 | 无 | 父进程返回子PID，子进程返回0 |
| `int wait(int* status)` | 等待子进程 | status: 退出状态指针 | 子进程PID |
| `void exit(int status)` | 进程退出 | status: 退出状态 | 不返回 |
| `int execv(const char* path, char* argv[])` | 执行程序 | path: 程序路径<br>argv: 参数数组 | 失败返回-1 |
| `int execl(const char* path, ...)` | 执行程序(变参) | path: 程序路径<br>...: 参数列表 | 失败返回-1 |
| `int getpid()` | 获取进程ID | 无 | 当前进程PID |
| `int proprint(char* buf, int len)` | 获取进程列表 | buf: 缓冲区<br>len: 缓冲区大小 | 写入字节数 |
| `int prokill(int pid)` | 终止进程 | pid: 目标进程ID | 成功返回0，失败返回-1 |

### 4.2 文件管理API

| 函数原型 | 功能 | 参数 | 返回值 |
|---------|------|------|--------|
| `int open(const char* path, int flags)` | 打开文件 | path: 文件路径<br>flags: 标志位 | 文件描述符 |
| `int close(int fd)` | 关闭文件 | fd: 文件描述符 | 成功返回0 |
| `int read(int fd, void* buf, int count)` | 读文件 | fd: 文件描述符<br>buf: 缓冲区<br>count: 字节数 | 实际读取字节数 |
| `int write(int fd, const void* buf, int count)` | 写文件 | fd: 文件描述符<br>buf: 缓冲区<br>count: 字节数 | 实际写入字节数 |
| `int unlink(const char* path)` | 删除文件 | path: 文件路径 | 成功返回0 |
| `int stat(const char* path, struct stat* buf)` | 获取文件状态 | path: 文件路径<br>buf: stat结构指针 | 成功返回0 |
| `int lseek(int fd, int offset, int whence)` | 文件定位 | fd: 文件描述符<br>offset: 偏移量<br>whence: 基准位置 | 新的文件位置 |

### 4.3 IPC API

| 函数原型 | 功能 | 参数 | 返回值 |
|---------|------|------|--------|
| `int send_recv(int function, int src_dest, MESSAGE* msg)` | 消息传递 | function: SEND/RECEIVE/BOTH<br>src_dest: 目标任务<br>msg: 消息指针 | 成功返回0 |

**function参数：**
- `SEND` (1) - 只发送消息
- `RECEIVE` (2) - 只接收消息
- `BOTH` (3) - 发送并等待接收

**src_dest常量：**
- `TASK_TTY` (0)
- `TASK_SYS` (1)
- `TASK_HD` (2)
- `TASK_FS` (3)
- `TASK_MM` (4)
- `ANY` (-1) - 接收任意进程消息

### 4.4 标准I/O API

| 函数原型 | 功能 | 参数 | 返回值 |
|---------|------|------|--------|
| `int printf(const char* fmt, ...)` | 格式化输出到stdout | fmt: 格式字符串<br>...: 参数 | 输出字符数 |
| `int sprintf(char* buf, const char* fmt, ...)` | 格式化到字符串 | buf: 目标缓冲区<br>fmt: 格式字符串<br>...: 参数 | 输出字符数 |
| `void printl(const char* fmt, ...)` | 打印到日志 | fmt: 格式字符串<br>...: 参数 | 无 |

---

## 五、数据结构定义

### 5.1 进程相关结构

#### struct proc (include/sys/proc.h:48-88)
```c
struct proc {
    struct stackframe regs;         /* 进程寄存器保存框架 */
    u16 ldt_sel;                   /* LDT选择器 */
    struct descriptor ldts[LDT_SIZE]; /* 局部描述符表 */

    int ticks;                     /* 剩余时间片 */
    int priority;                  /* 优先级 */

    char name[16];                 /* 进程名称 */
    int p_flags;                   /* 进程标志 */

    MESSAGE* p_msg;                /* 当前消息指针 */
    int p_recvfrom;                /* 期望接收源 */
    int p_sendto;                  /* 发送目标 */

    int has_int_msg;               /* 中断消息标志 */
    struct proc* q_sending;        /* 发送队列 */
    struct proc* next_sending;     /* 下一个发送者 */

    int p_parent;                  /* 父进程PID */
    int exit_status;               /* 退出状态 */
    struct file_desc* filp[NR_FILES]; /* 文件描述符表 */
};
```

**关键字段说明：**
- `p_flags = 0` → 进程可运行
- `p_flags != 0` → 进程阻塞/等待
- `p_parent = NO_TASK` → 顶层进程（无父进程）
- `exit_status` → 进程退出码（wait时返回）

#### struct task (include/sys/proc.h)
```c
struct task {
    task_f initial_eip;     /* 任务入口函数指针 */
    int stacksize;          /* 栈大小 */
    char name[32];          /* 任务名称 */
};
```

### 5.2 文件系统相关结构

#### struct inode (include/sys/fs.h:75-86)
```c
struct inode {
    u32 i_mode;             /* 文件类型和权限 */
    u32 i_size;             /* 文件大小(字节) */
    u32 i_start_sect;       /* 起始扇区号 */
    u32 i_nr_sects;         /* 占用扇区数 */
    u8 _unused[16];         /* 填充对齐 */

    /* 仅存在于内存中的字段 */
    int i_dev;              /* 设备号 */
    int i_cnt;              /* 引用计数 */
    int i_num;              /* inode号 */
};
```

**i_mode位定义：**
```c
#define I_TYPE_MASK     0170000   /* 文件类型掩码 */
#define I_REGULAR       0100000   /* 普通文件 */
#define I_DIRECTORY     0040000   /* 目录 */
#define I_BLOCK_SPECIAL 0060000   /* 块设备 */
#define I_CHAR_SPECIAL  0020000   /* 字符设备 */
```

#### struct stat (include/sys/stat.h)
```c
struct stat {
    int st_dev;       /* 设备号 */
    int st_ino;       /* inode号 */
    int st_mode;      /* 文件类型和权限 */
    int st_rdev;      /* 设备文件的设备号 */
    int st_size;      /* 文件大小(字节) */
};
```

#### struct file_desc (include/sys/fs.h)
```c
struct file_desc {
    int fd_mode;           /* 打开模式 */
    int fd_pos;            /* 当前文件位置 */
    int fd_cnt;            /* 引用计数 */
    struct inode* fd_inode; /* 指向inode */
};
```

#### struct dir_entry (include/sys/fs.h)
```c
struct dir_entry {
    int inode_nr;       /* inode号，0表示空项 */
    char name[MAX_FILENAME_LEN]; /* 文件名 */
};
```

### 5.3 消息相关结构

#### MESSAGE (include/type.h:53-62)
```c
typedef struct {
    int source;              /* 消息来源进程 */
    int type;                /* 消息类型 */
    char pBUF[500];         /* 通用缓冲区 */
    union {
        struct mess1 m1;    /* 整数参数 */
        struct mess2 m2;    /* 指针参数 */
        struct mess3 m3;    /* 混合参数 */
    } u;
} MESSAGE;
```

#### mess1, mess2, mess3
```c
struct mess1 {
    int m1i1, m1i2, m1i3, m1i4;
};

struct mess2 {
    void* m2p1, *m2p2, *m2p3, *m2p4;
};

struct mess3 {
    int m3i1, m3i2, m3i3, m3i4;
    void* m3p1, *m3p2, *m3p3, *m3p4;
};
```

**消息字段宏 (include/sys/const.h)：**
```c
#define FD          u.m3.m3i1      /* 文件描述符 */
#define PATHNAME    u.m3.m3p1      /* 路径名指针 */
#define FLAGS       u.m3.m3i1      /* 打开标志 */
#define NAME_LEN    u.m3.m3i2      /* 名称长度 */
#define BUF         u.m3.m3p2      /* 缓冲区指针 */
#define CNT         u.m3.m3i2      /* 字节计数 */
#define BUF_LEN     u.m3.m3i3      /* 缓冲区长度 */
#define RETVAL      u.m3.m3i1      /* 返回值 */
```

---

## 六、系统调用详解

### 6.1 进程管理系统调用流程

#### fork() - 创建子进程
```
用户进程                    MM任务
   |                          |
   | 1. fork()                |
   |------(FORK)------------->|
   |                          | 2. 分配进程槽
   |                          | 3. 复制进程结构
   |                          | 4. 复制内存
   |                          | 5. 设置返回值
   |<-----(SYSCALL_RET)-------|
   | 父进程: 返回子PID         |
   | 子进程: 返回0             |
```

**关键代码路径：**
1. `lib/fork.c:fork()` - 用户库函数
2. `send_recv(BOTH, TASK_MM, &msg)` - 发送消息
3. `mm/main.c:do_fork()` - MM任务处理
4. 返回给用户进程

#### execv() - 执行程序
```
用户进程                    MM任务                 FS任务
   |                          |                      |
   | 1. execv(path, argv)     |                      |
   |------(EXEC)------------->|                      |
   |                          | 2. 读取ELF文件       |
   |                          |------(READ)--------->|
   |                          |<----(文件数据)--------|
   |                          | 3. 解析ELF头         |
   |                          | 4. 分配内存          |
   |                          | 5. 加载程序段        |
   |                          | 6. 设置入口点        |
   |<-----(永不返回)----------|
   | 开始执行新程序            |
```

#### wait() - 等待子进程
```
父进程                      MM任务
   |                          |
   | 1. wait(&status)         |
   |------(WAIT)------------->|
   |                          | 2. 查找僵尸子进程
   |                          |    - 找到：立即返回
   |                          |    - 未找到：阻塞父进程
   |      (阻塞中...)         |
   |                          | (子进程exit时唤醒)
   |<-----(SYSCALL_RET)-------|
   | 返回子PID和status         |
```

### 6.2 文件管理系统调用流程

#### open() - 打开文件
```
用户进程                    FS任务                  HD任务
   |                          |                      |
   | 1. open(path, flags)     |                      |
   |------(OPEN)------------->|                      |
   |                          | 2. 解析路径          |
   |                          | 3. 查找inode         |
   |                          |------(DEV_READ)----->|
   |                          |<----(inode数据)------|
   |                          | 4. 分配file_desc     |
   |                          | 5. 分配fd号          |
   |<-----(SYSCALL_RET)-------|
   | 返回文件描述符fd          |
```

**O_CREAT标志处理：**
- 文件存在：直接打开
- 文件不存在：
  1. 分配空闲inode
  2. 创建目录项
  3. 更新inode映射位图
  4. 写入磁盘

#### stat() - 获取文件状态
```
用户进程                    FS任务
   |                          |
   | 1. stat(path, &st)       |
   |------(STAT)------------->|
   |                          | 2. 查找文件inode
   |                          | 3. 填充stat结构
   |<-----(SYSCALL_RET)-------|
   | stat结构已填充            |
```

**返回的信息：**
- `st_dev` - 设备号
- `st_ino` - inode号
- `st_mode` - 文件类型和权限
- `st_size` - 文件大小
- `st_rdev` - 设备文件的设备号

### 6.3 自定义系统调用流程

#### proprint() - 获取进程列表
```
ps命令                      FS任务
   |                          |
   | 1. proprint(buf, len)    |
   |------(PROPRINT)--------->|
   |                          | 2. 遍历proc_table[]
   |                          | 3. 格式化进程信息
   |                          | 4. 写入buf
   |<-----(SYSCALL_RET)-------|
   | 返回写入的字节数          |
   | buf中包含进程信息         |
```

**进程信息格式：**
```
PID\tNAME\tSTATUS\tPRI\tPARENT\tTICKS\n
0\tTASK_TTY\tRUN\t15\t-\t10\n
...
```

#### prokill() - 终止进程
```
kill命令                    FS任务                 MM任务
   |                          |                      |
   | 1. prokill(pid)          |                      |
   |------(PRO_KILL)--------->|                      |
   |                          | 2. 检查PID合法性     |
   |                          | 3. 关闭所有文件      |
   |                          | 4. 通知MM释放内存    |
   |                          |------(EXIT)--------->|
   |                          |                      | 5. 释放内存
   |                          | 6. 标记ZOMBIE        |
   |                          | 7. 唤醒父进程(可选)   |
   |<-----(SYSCALL_RET)-------|
   | 返回0表示成功             |
```

---

## 七、编译和集成清单

### 7.1 需要修改的Makefile片段

```makefile
# ===== 新增命令列表 =====
PS          = ps
KILL        = kill
OPENFILE    = open

COMMANDS    = touch rm ls cat echo pwd $(PS) $(KILL) $(OPENFILE)

# ===== 命令编译规则 =====
$(PS): command/ps.c $(LIB)
	$(CC) $(CFLAGS) -o $@ $< $(LIB)

$(KILL): command/kill.c $(LIB)
	$(CC) $(CFLAGS) -o $@ $< $(LIB)

$(OPENFILE): command/open.c $(LIB)
	$(CC) $(CFLAGS) -o $@ $< $(LIB)

# ===== 库对象文件 =====
LOBJS       = ... \
              lib/proprint.o \
              lib/prokill.o

lib/proprint.o: lib/proprint.c
	$(CC) $(CFLAGS) -c -o $@ $<

lib/prokill.o: lib/prokill.c
	$(CC) $(CFLAGS) -c -o $@ $<

# ===== FS模块对象文件 =====
FSOBJS      = fs/main.o \
              fs/open.o \
              fs/read_write.o \
              fs/link.o \
              fs/misc.o \
              fs/search_dir.o \
              fs/disklog.o \
              fs/proprint.o \
              fs/prokill.o

fs/proprint.o: fs/proprint.c
	$(CC) $(CFLAGS) -c -o $@ $<

fs/prokill.o: fs/prokill.c
	$(CC) $(CFLAGS) -c -o $@ $<
```

### 7.2 头文件修改

#### include/sys/proto.h
**需要添加的函数声明：**
```c
/* fs/proprint.c */
PUBLIC int do_proprint();

/* fs/prokill.c */
PUBLIC int do_prokill();

/* lib/proprint.c */
PUBLIC int proprint(char* buf, int buf_len);

/* lib/prokill.c */
PUBLIC int prokill(int pid);
```

### 7.3 完整的文件清单

**新增文件 (8个):**
1. `command/ps.c`
2. `command/kill.c`
3. `command/open.c`
4. `lib/proprint.c`
5. `lib/prokill.c`
6. `fs/proprint.c`
7. `fs/prokill.c`
8. `docs/技术实现路线.md`

**修改文件 (5个):**
1. `command/ls.c` - 增强文件属性显示
2. `kernel/main.c` - 优化Shell任务管理反馈
3. `fs/main.c` - 添加PROPRINT和PRO_KILL处理
4. `include/sys/proto.h` - 添加函数声明
5. `Makefile` - 添加编译规则

**保持不变的关键文件:**
- `include/sys/const.h` - 消息类型已定义
- `include/sys/proc.h` - 进程结构已完整
- `include/sys/fs.h` - 文件系统结构已完整
- 所有现有的lib/*.c系统调用库

---

## 八、测试代码清单

### 8.1 功能测试脚本

#### test_process.sh (Shell脚本概念)
```bash
# 进程管理测试

echo "=== Test 1: List processes ==="
ps

echo "\n=== Test 2: Start background process ==="
testA &

echo "\n=== Test 3: List processes again ==="
ps

echo "\n=== Test 4: Kill process ==="
kill 10

echo "\n=== Test 5: Verify process killed ==="
ps
```

### 8.2 压力测试代码

#### command/stress_test.c (概念)
```c
// 压力测试：创建多个进程
int main() {
    for (int i = 0; i < 20; i++) {
        int pid = fork();
        if (pid == 0) {
            // 子进程：运行一段时间后退出
            for (int j = 0; j < 1000000; j++);
            exit(0);
        }
    }

    // 父进程：等待所有子进程
    for (int i = 0; i < 20; i++) {
        wait(NULL);
    }

    printf("All child processes finished\n");
    return 0;
}
```

---

**文档版本**: 1.0
**创建日期**: 2026-01-01
**最后更新**: 2026-01-01
**总计文件**: 新增8个，修改5个
**总计代码行**: 约2000行
